### JS秘密花园: 闭包
闭包是很多开发者的一个痛点，尤其对初学者而言，就像雾里看花一样，怎样都没法彻底地将它拿下。笔者也曾走了很多弯路，读了很多博客、文档去学习理解。最近刚好得空，就将思路整理出来，供初学者参考，如有问题请指正。
#### 一、几个基本概念
在学习闭包之前，我们需要先掌握几个基本概念。

- 执行上下文
- 变量对象
- 作用域链

**1.1执行上下文(Execution Context)**
我们先来回顾一下执行上下文的概念，当调用一个函数(激活)时，一个新的执行上下文就会被创建。而一个执行上下文的声明周期分为两个阶段。

![执行上下文生命周期](https://github.com/HarrisChang/MarkDownImages/raw/master/3-2.png)<center>执行上下文生命周期</center>

执行上下文可理解为当前代码的执行环境，它会形成一个作用域。在一个JS程序中，会产生多个执行上下文，JS引擎会以堆栈的方式来处理它们(该堆栈称为函数调用栈)。栈底永远是全局上下文，且是唯一的一个，它在浏览器关闭的时候出栈。只有栈顶的上下文处于执行中，其他上下文需要等待。

**1.2变量对象(Variable Object)**
变量对象的创建，经历了以下几个过程。

![变量对象创建过程](https://github.com/HarrisChang/MarkDownImages/raw/master/3-3.png)<center>变量对象创建过程</center>

未进入执行阶段之前，变量对象中的属性不能访问。进入执行阶段之后，变量对象转变成了活动对象，里面的属性都可以访问，然后开始进行执行阶段的操作。

**1.3作用域链**

- 在JS中，作用域是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称(指的是变量名或函数名)进行变量查找。
- JS中只有全局作用域和函数作用域(eval在平时开发中几乎用不到)。
- 作用域链是该规则的具体实现。作用域链是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。
- 很多人以为当前作用域与上层作用域为包含关系，其实不是。以最前端为起点，最末端为终点的单向通道来形容更为贴切。我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。

![作用域链图示](https://github.com/HarrisChang/MarkDownImages/raw/master/4-3.png)
<center>作用域链图示</center>

<pre>
Question:执行环境和作用域有什么区别？
每个函数都有它的执行环境，当调用(激活)一个函数时，就会将其推入执行环境栈中，并产生一个新的执行上下文，函数执行完再将其弹出栈，返回到之前的执行环境。而每个执行环境又有其自己的变量对象，当代码在一个环境中执行时，会行程一个变量对象的作用域链，当前环境的变量对象在最前端，其外部执行环境的变量对象在下一级，一直回溯到全局环境的变量对象。作用域链保证了当前执行环境对符合访问权限的变量和函数的有序访问。当访问一个变量时，会从作用域链的最前端开始搜索，逐级向上。
</pre>

#### 二、闭包
我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放，`可是闭包的存在，会阻止这一过程。`
简单来讲，当你在函数A的内部定义了一个函数B，B的作用域链中就会包含A的变量对象，所以函数B可以访问函数A里定义的变量。而当函数A执行完毕后，其变量对象仍存在于内存中，这样就像是封闭了外部状态。

```
//demo01.js
function buildList(list) {
    var result = [];
    len = list.length;
    for (var i = 0; i < len; i++) {
        var item = 'item' + i;
        result.push( function() {
            console.log(item + ' ' + list[i])
        } );
    }
    return result;
}

function testList() {
    var fnList = buildList([1,2,3]);
    var lenF = fnList.length; 
    // Using j only to help prevent confusion -- could use i.
    for (var j = 0; j < lenF; j++) {
        fnList[j]();
    }
}
testList();//"item2 undefined" 3 times
```




